<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AboutUsText" xml:space="preserve">
    <value>Über uns</value>
  </data>
  <data name="Text" xml:space="preserve">
    <value>&lt;b&gt;&lt;i&gt;Verteiltes Rechnen f&amp;uuml;r Forschungsprojekte durch die Nutzung von bereits vorhandenen, freien IT-Ressourcen&lt;/b&gt;&lt;/i&gt;&lt;br&gt;
sGrid (=social Grid) ist ein Projekt des Karlsruher Instituts f&amp;uuml;r Technologie (KIT) am Institut f&amp;uuml;r Programmstrukturen und Datenorganisation (IPD) Prof. Dr. Walter F. Tichy und bietet die M&amp;ouml;glichkeit des verteilte Rechnen f&amp;uuml;r Forschungsprojekte durch die Nutzung von bereits vorhandenen und freien IT-Ressourcen dar. &lt;br&gt;
&lt;br&gt;
Die sGrid-Software wurde w&amp;auml;hrend des Wintersemesters 2012/2013 in der Veranstaltung „Praktikum der Softwareentwicklung“ durch KIT-Informatikstudenten Emanuel J&amp;ouml;bstl, J&amp;eacute;r&amp;ocirc;me Urhausen, Elisaweta Masserova und Ainara Askar entwickelt. Betreut werden die Studenten durch Alexander Wachtel. &lt;br&gt;
&lt;br&gt;
sGrid setzt auf der von der Universit&amp;auml;t Berkeley entwickelten Open-Source Software BOINC (Berkeley Open Infrastructure for Network Computing, &lt;a href="http://boinc.berkeley.edu/"&gt;http://boinc.berkeley.edu &lt;/a&gt;) auf, die das Durchf&amp;uuml;hren verteilten Rechnens erm&amp;ouml;glicht. sGrid ist ein Softwaresystem, bestehend aus einer Client- und einer Serveranwendung inklusive Webseite, das eine Br&amp;uuml;cke zwischen Wissenschaft und freiwilligen Benutzern aufbaut und eine Komplettl&amp;ouml;sung f&amp;uuml;r die Teilnahme an verteilten Rechenprojekten bereitstellt. &lt;br&gt;
Dabei erweitert sGrid die Funktionalit&amp;auml;t von BOINC durch:
&lt;ul&gt;
  &lt;li&gt;Leichte One-Click-Installation der Software sowie benutzerfreundliche Oberfl&amp;auml;che &lt;/li&gt;
  &lt;li&gt;Belohnungssystem als Anreiz f&amp;uuml;r die Freiwilligen an einem Projekt teilzunehmen &lt;/li&gt;
  &lt;li&gt;Soziale Interaktion &lt;/li&gt;
&lt;/ul&gt;
Der typische Ablauf der Nutzung der sGrid Software wird im Folgenden n&amp;auml;her beschrieben. Ein Benutzer kann sich mittels seiner E-Mail Adresse oder durch die Verwendung von OAuth- oder OpenId-Providern, wie Facebook, registrieren. Die Serveranwendung meldet neue Benutzer w&amp;auml;hrend der Registrierung automatisch auch bei dem jeweiligen Grid Partner an, damit Statistiken und Leistungen des Benutzers &amp;uuml;ber XML basierte Schnittstellen vom Grid Partner abgefragt werden k&amp;ouml;nnen. L&amp;auml;dt der Benutzer die Clientanwendung herunter und installiert diese, so bekommt die Clientanwendung Einstellungen und Benutzerinformationen von der Serveranwendung &amp;uuml;ber eine WCF Schnittstelle mitgeteilt, womit diese Arbeitspakete vom Grid Partner anfordern kann. Ist die Berechnung eines Arbeitspaketes abgeschlossen, wird das Ergebnis zur&amp;uuml;ck an den Grid Partner geleitet, zudem wird die Serveranwendung mittels WCF &amp;uuml;ber den Abschluss der Arbeit informiert. Die Clientanwendung kann nun mit einem neuen Arbeitspaket fortfahren. Wurden die Arbeitspakete vom Grid Partner akzeptiert, wird dem Benutzer die gespendete Rechenzeit gutgeschrieben, es k&amp;ouml;nnen nun beliebige Pr&amp;auml;mien f&amp;uuml;r die geleistete Rechenarbeit eingel&amp;ouml;st werden. &lt;br&gt;
&lt;br&gt;
BOINC verf&amp;uuml;gt heute &amp;uuml;ber 2.5 Mio. Benutzer, die ihre &amp;uuml;bersch&amp;uuml;ssige Rechenleistung diversen Hilfsprojekten zur Verf&amp;uuml;gung stellen. Das Ziel des sGrid-Projekts ist die Anzahl an Benutzern deutlich zu erh&amp;ouml;hen.</value>
  </data>
</root>