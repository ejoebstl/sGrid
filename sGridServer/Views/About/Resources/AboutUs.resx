<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AboutUsText" xml:space="preserve">
    <value>About us</value>
  </data>
  <data name="Text" xml:space="preserve">
    <value>&lt;b&gt;&lt;i&gt;Distributed computing for research projects by using surplus IT-resources&lt;/b&gt;&lt;/i&gt; &lt;br&gt;
sGrid (=social Grid) is a project at the Institute for Program Structures and Data Organization (IPD) Prof. Dr. Walter F. Tichy at the Karlsruhe Institute of Technology (KIT) and offers the possibility of distributed computing for research projects by using already available, surplus IT-resources. &lt;br&gt;
&lt;br&gt;
The sGrid-Software was developed in fall semester 2012/13 in the scope of the „Software Engineering Practice” course by KIT's computer science students Emanuel J&amp;ouml;bstl, J&amp;eacute;r&amp;ocirc;me Urhausen, Elisaweta Masserova and Ainara Askar. The team has been coached by Alexander Wachtel. &lt;br&gt;
&lt;br&gt;
sGrid builds on the Open-Source Software BOINC (Berkeley Open Infrastructure for Network Computing, &lt;a href="http://boinc.berkeley.edu/"&gt;http://boinc.berkeley.edu &lt;/a&gt;), which provides an open method for distributed computing. sGrid is a software system, composed of a client and a server application including a website, which builds a bridge between science projects and voluntary users and provides a complete solution for the participation at distributed computing projects. &lt;br&gt;
&lt;br&gt;
sGrid expands the functionality of BOINC through:
&lt;ul&gt;
  &lt;li&gt;An easy One-Click-Installation of the software and user-friendly Interface &lt;/li&gt;
  &lt;li&gt;A reward system in order to encourage volunteers to participate at the project &lt;/li&gt;
  &lt;li&gt;The possibility of social interaction &lt;/li&gt;
&lt;/ul&gt;
A typical use case of sGrid is described in the following section. A user can register with his e-mail address or through OAuth- or OpenId-Providers, such as Facebook. After this, the server application registers the user automatically with the corresponding Grid Partner, which enables sGrid to request statistics and performance reports of the user from this Grid Partner through web-based XML-interfaces. When the user downloads and installs the client application, the client application receives settings and user information from the server application through a WCF interface. With this information, work units can be requested from the Grid Partner. As soon as having finished the calculation on a work unit, the result will be submitted back to the Grid Partner, while the server application will be informed of this event. The client application can now continue work on a new unit.If the validation of the submitted result succeeded, the volunteered time will be immediately credited to the user, which can exchange the grant for various rewards. &lt;br&gt;
&lt;br&gt;
BOINC currently has 2.5 M Users, who donate their computing capacity to diverse charitable projects. The target of sGrid is to reasonably increase this count.</value>
  </data>
</root>